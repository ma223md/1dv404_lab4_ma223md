{"filter":false,"title":"qunit-1.16.0.js","tooltip":"/qUnit/qunit-1.16.0.js","undoManager":{"mark":0,"position":0,"stack":[[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":2818,"column":5},"action":"insert","lines":["/*!"," * QUnit 1.16.0"," * http://qunitjs.com/"," *"," * Copyright 2006, 2014 jQuery Foundation and other contributors"," * Released under the MIT license"," * http://jquery.org/license"," *"," * Date: 2014-12-03T16:32Z"," */","","(function( window ) {","","var QUnit,","\tconfig,","\tonErrorFnPrev,","\tloggingCallbacks = {},","\tfileName = ( sourceFromStacktrace( 0 ) || \"\" ).replace( /(:\\d+)+\\)?/, \"\" ).replace( /.+\\//, \"\" ),","\ttoString = Object.prototype.toString,","\thasOwn = Object.prototype.hasOwnProperty,","\t// Keep a local reference to Date (GH-283)","\tDate = window.Date,","\tnow = Date.now || function() {","\t\treturn new Date().getTime();","\t},","\tglobalStartCalled = false,","\trunStarted = false,","\tsetTimeout = window.setTimeout,","\tclearTimeout = window.clearTimeout,","\tdefined = {","\t\tdocument: window.document !== undefined,","\t\tsetTimeout: window.setTimeout !== undefined,","\t\tsessionStorage: (function() {","\t\t\tvar x = \"qunit-test-string\";","\t\t\ttry {","\t\t\t\tsessionStorage.setItem( x, x );","\t\t\t\tsessionStorage.removeItem( x );","\t\t\t\treturn true;","\t\t\t} catch ( e ) {","\t\t\t\treturn false;","\t\t\t}","\t\t}())","\t},","\t/**","\t * Provides a normalized error string, correcting an issue","\t * with IE 7 (and prior) where Error.prototype.toString is","\t * not properly implemented","\t *","\t * Based on http://es5.github.com/#x15.11.4.4","\t *","\t * @param {String|Error} error","\t * @return {String} error message","\t */","\terrorString = function( error ) {","\t\tvar name, message,","\t\t\terrorString = error.toString();","\t\tif ( errorString.substring( 0, 7 ) === \"[object\" ) {","\t\t\tname = error.name ? error.name.toString() : \"Error\";","\t\t\tmessage = error.message ? error.message.toString() : \"\";","\t\t\tif ( name && message ) {","\t\t\t\treturn name + \": \" + message;","\t\t\t} else if ( name ) {","\t\t\t\treturn name;","\t\t\t} else if ( message ) {","\t\t\t\treturn message;","\t\t\t} else {","\t\t\t\treturn \"Error\";","\t\t\t}","\t\t} else {","\t\t\treturn errorString;","\t\t}","\t},","\t/**","\t * Makes a clone of an object using only Array or Object as base,","\t * and copies over the own enumerable properties.","\t *","\t * @param {Object} obj","\t * @return {Object} New object with only the own properties (recursively).","\t */","\tobjectValues = function( obj ) {","\t\tvar key, val,","\t\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};","\t\tfor ( key in obj ) {","\t\t\tif ( hasOwn.call( obj, key ) ) {","\t\t\t\tval = obj[ key ];","\t\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;","\t\t\t}","\t\t}","\t\treturn vals;","\t};","","QUnit = {};","","/**"," * Config object: Maintain internal state"," * Later exposed as QUnit.config"," * `config` initialized at top of scope"," */","config = {","\t// The queue of tests to run","\tqueue: [],","","\t// block until document ready","\tblocking: true,","","\t// when enabled, show only failing tests","\t// gets persisted through sessionStorage and can be changed in UI via checkbox","\thidepassed: false,","","\t// by default, run previously failed tests first","\t// very useful in combination with \"Hide passed tests\" checked","\treorder: true,","","\t// by default, modify document.title when suite is done","\taltertitle: true,","","\t// by default, scroll to top of the page when suite is done","\tscrolltop: true,","","\t// when enabled, all tests must call expect()","\trequireExpects: false,","","\t// add checkboxes that are persisted in the query-string","\t// when enabled, the id is set to `true` as a `QUnit.config` property","\turlConfig: [","\t\t{","\t\t\tid: \"hidepassed\",","\t\t\tlabel: \"Hide passed tests\",","\t\t\ttooltip: \"Only show tests and assertions that fail. Stored as query-strings.\"","\t\t},","\t\t{","\t\t\tid: \"noglobals\",","\t\t\tlabel: \"Check for Globals\",","\t\t\ttooltip: \"Enabling this will test if any test introduces new properties on the \" +","\t\t\t\t\"`window` object. Stored as query-strings.\"","\t\t},","\t\t{","\t\t\tid: \"notrycatch\",","\t\t\tlabel: \"No try-catch\",","\t\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging \" +","\t\t\t\t\"exceptions in IE reasonable. Stored as query-strings.\"","\t\t}","\t],","","\t// Set of all modules.","\tmodules: [],","","\t// The first unnamed module","\tcurrentModule: {","\t\tname: \"\",","\t\ttests: []","\t},","","\tcallbacks: {}","};","","// Push a loose unnamed module to the modules collection","config.modules.push( config.currentModule );","","// Initialize more QUnit.config and QUnit.urlParams","(function() {","\tvar i, current,","\t\tlocation = window.location || { search: \"\", protocol: \"file:\" },","\t\tparams = location.search.slice( 1 ).split( \"&\" ),","\t\tlength = params.length,","\t\turlParams = {};","","\tif ( params[ 0 ] ) {","\t\tfor ( i = 0; i < length; i++ ) {","\t\t\tcurrent = params[ i ].split( \"=\" );","\t\t\tcurrent[ 0 ] = decodeURIComponent( current[ 0 ] );","","\t\t\t// allow just a key to turn on a flag, e.g., test.html?noglobals","\t\t\tcurrent[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;","\t\t\tif ( urlParams[ current[ 0 ] ] ) {","\t\t\t\turlParams[ current[ 0 ] ] = [].concat( urlParams[ current[ 0 ] ], current[ 1 ] );","\t\t\t} else {","\t\t\t\turlParams[ current[ 0 ] ] = current[ 1 ];","\t\t\t}","\t\t}","\t}","","\tQUnit.urlParams = urlParams;","","\t// String search anywhere in moduleName+testName","\tconfig.filter = urlParams.filter;","","\tconfig.testId = [];","\tif ( urlParams.testId ) {","","\t\t// Ensure that urlParams.testId is an array","\t\turlParams.testId = [].concat( urlParams.testId );","\t\tfor ( i = 0; i < urlParams.testId.length; i++ ) {","\t\t\tconfig.testId.push( urlParams.testId[ i ] );","\t\t}","\t}","","\t// Figure out if we're running the tests from a server or not","\tQUnit.isLocal = location.protocol === \"file:\";","}());","","// Root QUnit object.","// `QUnit` initialized at top of scope","extend( QUnit, {","","\t// call on start of module test to prepend name to all tests","\tmodule: function( name, testEnvironment ) {","\t\tvar currentModule = {","\t\t\tname: name,","\t\t\ttestEnvironment: testEnvironment,","\t\t\ttests: []","\t\t};","","\t\t// DEPRECATED: handles setup/teardown functions,","\t\t// beforeEach and afterEach should be used instead","\t\tif ( testEnvironment && testEnvironment.setup ) {","\t\t\ttestEnvironment.beforeEach = testEnvironment.setup;","\t\t\tdelete testEnvironment.setup;","\t\t}","\t\tif ( testEnvironment && testEnvironment.teardown ) {","\t\t\ttestEnvironment.afterEach = testEnvironment.teardown;","\t\t\tdelete testEnvironment.teardown;","\t\t}","","\t\tconfig.modules.push( currentModule );","\t\tconfig.currentModule = currentModule;","\t},","","\t// DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.","\tasyncTest: function( testName, expected, callback ) {","\t\tif ( arguments.length === 2 ) {","\t\t\tcallback = expected;","\t\t\texpected = null;","\t\t}","","\t\tQUnit.test( testName, expected, callback, true );","\t},","","\ttest: function( testName, expected, callback, async ) {","\t\tvar test;","","\t\tif ( arguments.length === 2 ) {","\t\t\tcallback = expected;","\t\t\texpected = null;","\t\t}","","\t\ttest = new Test({","\t\t\ttestName: testName,","\t\t\texpected: expected,","\t\t\tasync: async,","\t\t\tcallback: callback","\t\t});","","\t\ttest.queue();","\t},","","\tskip: function( testName ) {","\t\tvar test = new Test({","\t\t\ttestName: testName,","\t\t\tskip: true","\t\t});","","\t\ttest.queue();","\t},","","\t// DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.","\t// In QUnit 2.0, invoking it will ONLY affect the `QUnit.config.autostart` blocking behavior.","\tstart: function( count ) {","\t\tvar globalStartAlreadyCalled = globalStartCalled;","","\t\tif ( !config.current ) {","\t\t\tglobalStartCalled = true;","","\t\t\tif ( runStarted ) {","\t\t\t\tthrow new Error( \"Called start() outside of a test context while already started\" );","\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {","\t\t\t\tthrow new Error( \"Called start() outside of a test context too many times\" );","\t\t\t} else if ( config.autostart ) {","\t\t\t\tthrow new Error( \"Called start() outside of a test context when \" +","\t\t\t\t\t\"QUnit.config.autostart was true\" );","\t\t\t} else if ( !config.pageLoaded ) {","","\t\t\t\t// The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it","\t\t\t\tconfig.autostart = true;","\t\t\t\treturn;","\t\t\t}","\t\t} else {","","\t\t\t// If a test is running, adjust its semaphore","\t\t\tconfig.current.semaphore -= count || 1;","","\t\t\t// Don't start until equal number of stop-calls","\t\t\tif ( config.current.semaphore > 0 ) {","\t\t\t\treturn;","\t\t\t}","","\t\t\t// throw an Error if start is called more often than stop","\t\t\tif ( config.current.semaphore < 0 ) {","\t\t\t\tconfig.current.semaphore = 0;","","\t\t\t\tQUnit.pushFailure(","\t\t\t\t\t\"Called start() while already started (test's semaphore was 0 already)\",","\t\t\t\t\tsourceFromStacktrace( 2 )","\t\t\t\t);","\t\t\t\treturn;","\t\t\t}","\t\t}","","\t\tresumeProcessing();","\t},","","\t// DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.","\tstop: function( count ) {","","\t\t// If there isn't a test running, don't allow QUnit.stop() to be called","\t\tif ( !config.current ) {","\t\t\tthrow new Error( \"Called stop() outside of a test context\" );","\t\t}","","\t\t// If a test is running, adjust its semaphore","\t\tconfig.current.semaphore += count || 1;","","\t\tpauseProcessing();","\t},","","\tconfig: config,","","\t// Safe object type checking","\tis: function( type, obj ) {","\t\treturn QUnit.objectType( obj ) === type;","\t},","","\tobjectType: function( obj ) {","\t\tif ( typeof obj === \"undefined\" ) {","\t\t\treturn \"undefined\";","\t\t}","","\t\t// Consider: typeof null === object","\t\tif ( obj === null ) {","\t\t\treturn \"null\";","\t\t}","","\t\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),","\t\t\ttype = match && match[ 1 ] || \"\";","","\t\tswitch ( type ) {","\t\t\tcase \"Number\":","\t\t\t\tif ( isNaN( obj ) ) {","\t\t\t\t\treturn \"nan\";","\t\t\t\t}","\t\t\t\treturn \"number\";","\t\t\tcase \"String\":","\t\t\tcase \"Boolean\":","\t\t\tcase \"Array\":","\t\t\tcase \"Date\":","\t\t\tcase \"RegExp\":","\t\t\tcase \"Function\":","\t\t\t\treturn type.toLowerCase();","\t\t}","\t\tif ( typeof obj === \"object\" ) {","\t\t\treturn \"object\";","\t\t}","\t\treturn undefined;","\t},","","\turl: function( params ) {","\t\tparams = extend( extend( {}, QUnit.urlParams ), params );","\t\tvar key,","\t\t\tquerystring = \"?\";","","\t\tfor ( key in params ) {","\t\t\tif ( hasOwn.call( params, key ) ) {","\t\t\t\tquerystring += encodeURIComponent( key );","\t\t\t\tif ( params[ key ] !== true ) {","\t\t\t\t\tquerystring += \"=\" + encodeURIComponent( params[ key ] );","\t\t\t\t}","\t\t\t\tquerystring += \"&\";","\t\t\t}","\t\t}","\t\treturn location.protocol + \"//\" + location.host +","\t\t\tlocation.pathname + querystring.slice( 0, -1 );","\t},","","\textend: extend,","","\tload: function() {","\t\tconfig.pageLoaded = true;","","\t\t// Initialize the configuration options","\t\textend( config, {","\t\t\tstats: { all: 0, bad: 0 },","\t\t\tmoduleStats: { all: 0, bad: 0 },","\t\t\tstarted: 0,","\t\t\tupdateRate: 1000,","\t\t\tautostart: true,","\t\t\tfilter: \"\"","\t\t}, true );","","\t\tconfig.blocking = false;","","\t\tif ( config.autostart ) {","\t\t\tresumeProcessing();","\t\t}","\t}","});","","// Register logging callbacks","(function() {","\tvar i, l, key,","\t\tcallbacks = [ \"begin\", \"done\", \"log\", \"testStart\", \"testDone\",","\t\t\t\"moduleStart\", \"moduleDone\" ];","","\tfunction registerLoggingCallback( key ) {","\t\tvar loggingCallback = function( callback ) {","\t\t\tif ( QUnit.objectType( callback ) !== \"function\" ) {","\t\t\t\tthrow new Error(","\t\t\t\t\t\"QUnit logging methods require a callback function as their first parameters.\"","\t\t\t\t);","\t\t\t}","","\t\t\tconfig.callbacks[ key ].push( callback );","\t\t};","","\t\t// DEPRECATED: This will be removed on QUnit 2.0.0+","\t\t// Stores the registered functions allowing restoring","\t\t// at verifyLoggingCallbacks() if modified","\t\tloggingCallbacks[ key ] = loggingCallback;","","\t\treturn loggingCallback;","\t}","","\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {","\t\tkey = callbacks[ i ];","","\t\t// Initialize key collection of logging callback","\t\tif ( QUnit.objectType( config.callbacks[ key ] ) === \"undefined\" ) {","\t\t\tconfig.callbacks[ key ] = [];","\t\t}","","\t\tQUnit[ key ] = registerLoggingCallback( key );","\t}","})();","","// `onErrorFnPrev` initialized at top of scope","// Preserve other handlers","onErrorFnPrev = window.onerror;","","// Cover uncaught exceptions","// Returning true will suppress the default browser handler,","// returning false will let it run.","window.onerror = function( error, filePath, linerNr ) {","\tvar ret = false;","\tif ( onErrorFnPrev ) {","\t\tret = onErrorFnPrev( error, filePath, linerNr );","\t}","","\t// Treat return value as window.onerror itself does,","\t// Only do our handling if not suppressed.","\tif ( ret !== true ) {","\t\tif ( QUnit.config.current ) {","\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {","\t\t\t\treturn true;","\t\t\t}","\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );","\t\t} else {","\t\t\tQUnit.test( \"global failure\", extend(function() {","\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );","\t\t\t}, { validTest: true } ) );","\t\t}","\t\treturn false;","\t}","","\treturn ret;","};","","function done() {","\tvar runtime, passed;","","\tconfig.autorun = true;","","\t// Log the last module results","\tif ( config.previousModule ) {","\t\trunLoggingCallbacks( \"moduleDone\", {","\t\t\tname: config.previousModule.name,","\t\t\ttests: config.previousModule.tests,","\t\t\tfailed: config.moduleStats.bad,","\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,","\t\t\ttotal: config.moduleStats.all,","\t\t\truntime: now() - config.moduleStats.started","\t\t});","\t}","\tdelete config.previousModule;","","\truntime = now() - config.started;","\tpassed = config.stats.all - config.stats.bad;","","\trunLoggingCallbacks( \"done\", {","\t\tfailed: config.stats.bad,","\t\tpassed: passed,","\t\ttotal: config.stats.all,","\t\truntime: runtime","\t});","}","","// Doesn't support IE6 to IE9","// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack","function extractStacktrace( e, offset ) {","\toffset = offset === undefined ? 4 : offset;","","\tvar stack, include, i;","","\tif ( e.stacktrace ) {","","\t\t// Opera 12.x","\t\treturn e.stacktrace.split( \"\\n\" )[ offset + 3 ];","\t} else if ( e.stack ) {","","\t\t// Firefox, Chrome, Safari 6+, IE10+, PhantomJS and Node","\t\tstack = e.stack.split( \"\\n\" );","\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {","\t\t\tstack.shift();","\t\t}","\t\tif ( fileName ) {","\t\t\tinclude = [];","\t\t\tfor ( i = offset; i < stack.length; i++ ) {","\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {","\t\t\t\t\tbreak;","\t\t\t\t}","\t\t\t\tinclude.push( stack[ i ] );","\t\t\t}","\t\t\tif ( include.length ) {","\t\t\t\treturn include.join( \"\\n\" );","\t\t\t}","\t\t}","\t\treturn stack[ offset ];","\t} else if ( e.sourceURL ) {","","\t\t// Safari < 6","\t\t// exclude useless self-reference for generated Error objects","\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {","\t\t\treturn;","\t\t}","","\t\t// for actual exceptions, this is useful","\t\treturn e.sourceURL + \":\" + e.line;","\t}","}","","function sourceFromStacktrace( offset ) {","\tvar e = new Error();","\tif ( !e.stack ) {","\t\ttry {","\t\t\tthrow e;","\t\t} catch ( err ) {","\t\t\t// This should already be true in most browsers","\t\t\te = err;","\t\t}","\t}","\treturn extractStacktrace( e, offset );","}","","function synchronize( callback, last ) {","\tif ( QUnit.objectType( callback ) === \"array\" ) {","\t\twhile ( callback.length ) {","\t\t\tsynchronize( callback.shift() );","\t\t}","\t\treturn;","\t}","\tconfig.queue.push( callback );","","\tif ( config.autorun && !config.blocking ) {","\t\tprocess( last );","\t}","}","","function process( last ) {","\tfunction next() {","\t\tprocess( last );","\t}","\tvar start = now();","\tconfig.depth = config.depth ? config.depth + 1 : 1;","","\twhile ( config.queue.length && !config.blocking ) {","\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||","\t\t\t\t( ( now() - start ) < config.updateRate ) ) {","\t\t\tif ( config.current ) {","","\t\t\t\t// Reset async tracking for each phase of the Test lifecycle","\t\t\t\tconfig.current.usedAsync = false;","\t\t\t}","\t\t\tconfig.queue.shift()();","\t\t} else {","\t\t\tsetTimeout( next, 13 );","\t\t\tbreak;","\t\t}","\t}","\tconfig.depth--;","\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {","\t\tdone();","\t}","}","","function begin() {","\tvar i, l,","\t\tmodulesLog = [];","","\t// If the test run hasn't officially begun yet","\tif ( !config.started ) {","","\t\t// Record the time of the test run's beginning","\t\tconfig.started = now();","","\t\tverifyLoggingCallbacks();","","\t\t// Delete the loose unnamed module if unused.","\t\tif ( config.modules[ 0 ].name === \"\" && config.modules[ 0 ].tests.length === 0 ) {","\t\t\tconfig.modules.shift();","\t\t}","","\t\t// Avoid unnecessary information by not logging modules' test environments","\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {","\t\t\tmodulesLog.push({","\t\t\t\tname: config.modules[ i ].name,","\t\t\t\ttests: config.modules[ i ].tests","\t\t\t});","\t\t}","","\t\t// The test run is officially beginning now","\t\trunLoggingCallbacks( \"begin\", {","\t\t\ttotalTests: Test.count,","\t\t\tmodules: modulesLog","\t\t});","\t}","","\tconfig.blocking = false;","\tprocess( true );","}","","function resumeProcessing() {","\trunStarted = true;","","\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)","\tif ( defined.setTimeout ) {","\t\tsetTimeout(function() {","\t\t\tif ( config.current && config.current.semaphore > 0 ) {","\t\t\t\treturn;","\t\t\t}","\t\t\tif ( config.timeout ) {","\t\t\t\tclearTimeout( config.timeout );","\t\t\t}","","\t\t\tbegin();","\t\t}, 13 );","\t} else {","\t\tbegin();","\t}","}","","function pauseProcessing() {","\tconfig.blocking = true;","","\tif ( config.testTimeout && defined.setTimeout ) {","\t\tclearTimeout( config.timeout );","\t\tconfig.timeout = setTimeout(function() {","\t\t\tif ( config.current ) {","\t\t\t\tconfig.current.semaphore = 0;","\t\t\t\tQUnit.pushFailure( \"Test timed out\", sourceFromStacktrace( 2 ) );","\t\t\t} else {","\t\t\t\tthrow new Error( \"Test timed out\" );","\t\t\t}","\t\t\tresumeProcessing();","\t\t}, config.testTimeout );","\t}","}","","function saveGlobal() {","\tconfig.pollution = [];","","\tif ( config.noglobals ) {","\t\tfor ( var key in window ) {","\t\t\tif ( hasOwn.call( window, key ) ) {","\t\t\t\t// in Opera sometimes DOM element ids show up here, ignore them","\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {","\t\t\t\t\tcontinue;","\t\t\t\t}","\t\t\t\tconfig.pollution.push( key );","\t\t\t}","\t\t}","\t}","}","","function checkPollution() {","\tvar newGlobals,","\t\tdeletedGlobals,","\t\told = config.pollution;","","\tsaveGlobal();","","\tnewGlobals = diff( config.pollution, old );","\tif ( newGlobals.length > 0 ) {","\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join( \", \" ) );","\t}","","\tdeletedGlobals = diff( old, config.pollution );","\tif ( deletedGlobals.length > 0 ) {","\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join( \", \" ) );","\t}","}","","// returns a new Array with the elements that are in a but not in b","function diff( a, b ) {","\tvar i, j,","\t\tresult = a.slice();","","\tfor ( i = 0; i < result.length; i++ ) {","\t\tfor ( j = 0; j < b.length; j++ ) {","\t\t\tif ( result[ i ] === b[ j ] ) {","\t\t\t\tresult.splice( i, 1 );","\t\t\t\ti--;","\t\t\t\tbreak;","\t\t\t}","\t\t}","\t}","\treturn result;","}","","function extend( a, b, undefOnly ) {","\tfor ( var prop in b ) {","\t\tif ( hasOwn.call( b, prop ) ) {","","\t\t\t// Avoid \"Member not found\" error in IE8 caused by messing with window.constructor","\t\t\tif ( !( prop === \"constructor\" && a === window ) ) {","\t\t\t\tif ( b[ prop ] === undefined ) {","\t\t\t\t\tdelete a[ prop ];","\t\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== \"undefined\" ) ) {","\t\t\t\t\ta[ prop ] = b[ prop ];","\t\t\t\t}","\t\t\t}","\t\t}","\t}","","\treturn a;","}","","function runLoggingCallbacks( key, args ) {","\tvar i, l, callbacks;","","\tcallbacks = config.callbacks[ key ];","\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {","\t\tcallbacks[ i ]( args );","\t}","}","","// DEPRECATED: This will be removed on 2.0.0+","// This function verifies if the loggingCallbacks were modified by the user","// If so, it will restore it, assign the given callback and print a console warning","function verifyLoggingCallbacks() {","\tvar loggingCallback, userCallback;","","\tfor ( loggingCallback in loggingCallbacks ) {","\t\tif ( QUnit[ loggingCallback ] !== loggingCallbacks[ loggingCallback ] ) {","","\t\t\tuserCallback = QUnit[ loggingCallback ];","","\t\t\t// Restore the callback function","\t\t\tQUnit[ loggingCallback ] = loggingCallbacks[ loggingCallback ];","","\t\t\t// Assign the deprecated given callback","\t\t\tQUnit[ loggingCallback ]( userCallback );","","\t\t\tif ( window.console && window.console.warn ) {","\t\t\t\twindow.console.warn(","\t\t\t\t\t\"QUnit.\" + loggingCallback + \" was replaced with a new value.\\n\" +","\t\t\t\t\t\"Please, check out the documentation on how to apply logging callbacks.\\n\" +","\t\t\t\t\t\"Reference: http://api.qunitjs.com/category/callbacks/\"","\t\t\t\t);","\t\t\t}","\t\t}","\t}","}","","// from jquery.js","function inArray( elem, array ) {","\tif ( array.indexOf ) {","\t\treturn array.indexOf( elem );","\t}","","\tfor ( var i = 0, length = array.length; i < length; i++ ) {","\t\tif ( array[ i ] === elem ) {","\t\t\treturn i;","\t\t}","\t}","","\treturn -1;","}","","function Test( settings ) {","\tvar i, l;","","\t++Test.count;","","\textend( this, settings );","\tthis.assertions = [];","\tthis.semaphore = 0;","\tthis.usedAsync = false;","\tthis.module = config.currentModule;","\tthis.stack = sourceFromStacktrace( 3 );","","\t// Register unique strings","\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {","\t\tif ( this.module.tests[ i ].name === this.testName ) {","\t\t\tthis.testName += \" \";","\t\t}","\t}","","\tthis.testId = generateHash( this.module.name, this.testName );","","\tthis.module.tests.push({","\t\tname: this.testName,","\t\ttestId: this.testId","\t});","","\tif ( settings.skip ) {","","\t\t// Skipped tests will fully ignore any sent callback","\t\tthis.callback = function() {};","\t\tthis.async = false;","\t\tthis.expected = 0;","\t} else {","\t\tthis.assert = new Assert( this );","\t}","}","","Test.count = 0;","","Test.prototype = {","\tbefore: function() {","\t\tif (","","\t\t\t// Emit moduleStart when we're switching from one module to another","\t\t\tthis.module !== config.previousModule ||","","\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't","\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a","\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.","\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.","\t\t\t\t!hasOwn.call( config, \"previousModule\" )","\t\t) {","\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {","\t\t\t\trunLoggingCallbacks( \"moduleDone\", {","\t\t\t\t\tname: config.previousModule.name,","\t\t\t\t\ttests: config.previousModule.tests,","\t\t\t\t\tfailed: config.moduleStats.bad,","\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,","\t\t\t\t\ttotal: config.moduleStats.all,","\t\t\t\t\truntime: now() - config.moduleStats.started","\t\t\t\t});","\t\t\t}","\t\t\tconfig.previousModule = this.module;","\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };","\t\t\trunLoggingCallbacks( \"moduleStart\", {","\t\t\t\tname: this.module.name,","\t\t\t\ttests: this.module.tests","\t\t\t});","\t\t}","","\t\tconfig.current = this;","","\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );","\t\tdelete this.testEnvironment.beforeEach;","\t\tdelete this.testEnvironment.afterEach;","","\t\tthis.started = now();","\t\trunLoggingCallbacks( \"testStart\", {","\t\t\tname: this.testName,","\t\t\tmodule: this.module.name,","\t\t\ttestId: this.testId","\t\t});","","\t\tif ( !config.pollution ) {","\t\t\tsaveGlobal();","\t\t}","\t},","","\trun: function() {","\t\tvar promise;","","\t\tconfig.current = this;","","\t\tif ( this.async ) {","\t\t\tQUnit.stop();","\t\t}","","\t\tthis.callbackStarted = now();","","\t\tif ( config.notrycatch ) {","\t\t\tpromise = this.callback.call( this.testEnvironment, this.assert );","\t\t\tthis.resolvePromise( promise );","\t\t\treturn;","\t\t}","","\t\ttry {","\t\t\tpromise = this.callback.call( this.testEnvironment, this.assert );","\t\t\tthis.resolvePromise( promise );","\t\t} catch ( e ) {","\t\t\tthis.pushFailure( \"Died on test #\" + ( this.assertions.length + 1 ) + \" \" +","\t\t\t\tthis.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );","","\t\t\t// else next test will carry the responsibility","\t\t\tsaveGlobal();","","\t\t\t// Restart the tests if they're blocking","\t\t\tif ( config.blocking ) {","\t\t\t\tQUnit.start();","\t\t\t}","\t\t}","\t},","","\tafter: function() {","\t\tcheckPollution();","\t},","","\tqueueHook: function( hook, hookName ) {","\t\tvar promise,","\t\t\ttest = this;","\t\treturn function runHook() {","\t\t\tconfig.current = test;","\t\t\tif ( config.notrycatch ) {","\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );","\t\t\t\ttest.resolvePromise( promise, hookName );","\t\t\t\treturn;","\t\t\t}","\t\t\ttry {","\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );","\t\t\t\ttest.resolvePromise( promise, hookName );","\t\t\t} catch ( error ) {","\t\t\t\ttest.pushFailure( hookName + \" failed on \" + test.testName + \": \" +","\t\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );","\t\t\t}","\t\t};","\t},","","\t// Currently only used for module level hooks, can be used to add global level ones","\thooks: function( handler ) {","\t\tvar hooks = [];","","\t\t// Hooks are ignored on skipped tests","\t\tif ( this.skip ) {","\t\t\treturn hooks;","\t\t}","","\t\tif ( this.module.testEnvironment &&","\t\t\t\tQUnit.objectType( this.module.testEnvironment[ handler ] ) === \"function\" ) {","\t\t\thooks.push( this.queueHook( this.module.testEnvironment[ handler ], handler ) );","\t\t}","","\t\treturn hooks;","\t},","","\tfinish: function() {","\t\tconfig.current = this;","\t\tif ( config.requireExpects && this.expected === null ) {","\t\t\tthis.pushFailure( \"Expected number of assertions to be defined, but expect() was \" +","\t\t\t\t\"not called.\", this.stack );","\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {","\t\t\tthis.pushFailure( \"Expected \" + this.expected + \" assertions, but \" +","\t\t\t\tthis.assertions.length + \" were run\", this.stack );","\t\t} else if ( this.expected === null && !this.assertions.length ) {","\t\t\tthis.pushFailure( \"Expected at least one assertion, but none were run - call \" +","\t\t\t\t\"expect(0) to accept zero assertions.\", this.stack );","\t\t}","","\t\tvar i,","\t\t\tbad = 0;","","\t\tthis.runtime = now() - this.started;","\t\tconfig.stats.all += this.assertions.length;","\t\tconfig.moduleStats.all += this.assertions.length;","","\t\tfor ( i = 0; i < this.assertions.length; i++ ) {","\t\t\tif ( !this.assertions[ i ].result ) {","\t\t\t\tbad++;","\t\t\t\tconfig.stats.bad++;","\t\t\t\tconfig.moduleStats.bad++;","\t\t\t}","\t\t}","","\t\trunLoggingCallbacks( \"testDone\", {","\t\t\tname: this.testName,","\t\t\tmodule: this.module.name,","\t\t\tskipped: !!this.skip,","\t\t\tfailed: bad,","\t\t\tpassed: this.assertions.length - bad,","\t\t\ttotal: this.assertions.length,","\t\t\truntime: this.runtime,","","\t\t\t// HTML Reporter use","\t\t\tassertions: this.assertions,","\t\t\ttestId: this.testId,","","\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead","\t\t\tduration: this.runtime","\t\t});","","\t\t// QUnit.reset() is deprecated and will be replaced for a new","\t\t// fixture reset function on QUnit 2.0/2.1.","\t\t// It's still called here for backwards compatibility handling","\t\tQUnit.reset();","","\t\tconfig.current = undefined;","\t},","","\tqueue: function() {","\t\tvar bad,","\t\t\ttest = this;","","\t\tif ( !this.valid() ) {","\t\t\treturn;","\t\t}","","\t\tfunction run() {","","\t\t\t// each of these can by async","\t\t\tsynchronize([","\t\t\t\tfunction() {","\t\t\t\t\ttest.before();","\t\t\t\t},","","\t\t\t\ttest.hooks( \"beforeEach\" ),","","\t\t\t\tfunction() {","\t\t\t\t\ttest.run();","\t\t\t\t},","","\t\t\t\ttest.hooks( \"afterEach\" ).reverse(),","","\t\t\t\tfunction() {","\t\t\t\t\ttest.after();","\t\t\t\t},","\t\t\t\tfunction() {","\t\t\t\t\ttest.finish();","\t\t\t\t}","\t\t\t]);","\t\t}","","\t\t// `bad` initialized at top of scope","\t\t// defer when previous test run passed, if storage is available","\t\tbad = QUnit.config.reorder && defined.sessionStorage &&","\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module.name + \"-\" + this.testName );","","\t\tif ( bad ) {","\t\t\trun();","\t\t} else {","\t\t\tsynchronize( run, true );","\t\t}","\t},","","\tpush: function( result, actual, expected, message ) {","\t\tvar source,","\t\t\tdetails = {","\t\t\t\tmodule: this.module.name,","\t\t\t\tname: this.testName,","\t\t\t\tresult: result,","\t\t\t\tmessage: message,","\t\t\t\tactual: actual,","\t\t\t\texpected: expected,","\t\t\t\ttestId: this.testId,","\t\t\t\truntime: now() - this.started","\t\t\t};","","\t\tif ( !result ) {","\t\t\tsource = sourceFromStacktrace();","","\t\t\tif ( source ) {","\t\t\t\tdetails.source = source;","\t\t\t}","\t\t}","","\t\trunLoggingCallbacks( \"log\", details );","","\t\tthis.assertions.push({","\t\t\tresult: !!result,","\t\t\tmessage: message","\t\t});","\t},","","\tpushFailure: function( message, source, actual ) {","\t\tif ( !this instanceof Test ) {","\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" +","\t\t\t\tsourceFromStacktrace( 2 ) );","\t\t}","","\t\tvar details = {","\t\t\t\tmodule: this.module.name,","\t\t\t\tname: this.testName,","\t\t\t\tresult: false,","\t\t\t\tmessage: message || \"error\",","\t\t\t\tactual: actual || null,","\t\t\t\ttestId: this.testId,","\t\t\t\truntime: now() - this.started","\t\t\t};","","\t\tif ( source ) {","\t\t\tdetails.source = source;","\t\t}","","\t\trunLoggingCallbacks( \"log\", details );","","\t\tthis.assertions.push({","\t\t\tresult: false,","\t\t\tmessage: message","\t\t});","\t},","","\tresolvePromise: function( promise, phase ) {","\t\tvar then, message,","\t\t\ttest = this;","\t\tif ( promise != null ) {","\t\t\tthen = promise.then;","\t\t\tif ( QUnit.objectType( then ) === \"function\" ) {","\t\t\t\tQUnit.stop();","\t\t\t\tthen.call(","\t\t\t\t\tpromise,","\t\t\t\t\tQUnit.start,","\t\t\t\t\tfunction( error ) {","\t\t\t\t\t\tmessage = \"Promise rejected \" +","\t\t\t\t\t\t\t( !phase ? \"during\" : phase.replace( /Each$/, \"\" ) ) +","\t\t\t\t\t\t\t\" \" + test.testName + \": \" + ( error.message || error );","\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );","","\t\t\t\t\t\t// else next test will carry the responsibility","\t\t\t\t\t\tsaveGlobal();","","\t\t\t\t\t\t// Unblock","\t\t\t\t\t\tQUnit.start();","\t\t\t\t\t}","\t\t\t\t);","\t\t\t}","\t\t}","\t},","","\tvalid: function() {","\t\tvar include,","\t\t\tfilter = config.filter && config.filter.toLowerCase(),","\t\t\tmodule = QUnit.urlParams.module && QUnit.urlParams.module.toLowerCase(),","\t\t\tfullName = ( this.module.name + \": \" + this.testName ).toLowerCase();","","\t\t// Internally-generated tests are always valid","\t\tif ( this.callback && this.callback.validTest ) {","\t\t\treturn true;","\t\t}","","\t\tif ( config.testId.length > 0 && inArray( this.testId, config.testId ) < 0 ) {","\t\t\treturn false;","\t\t}","","\t\tif ( module && ( !this.module.name || this.module.name.toLowerCase() !== module ) ) {","\t\t\treturn false;","\t\t}","","\t\tif ( !filter ) {","\t\t\treturn true;","\t\t}","","\t\tinclude = filter.charAt( 0 ) !== \"!\";","\t\tif ( !include ) {","\t\t\tfilter = filter.slice( 1 );","\t\t}","","\t\t// If the filter matches, we need to honour include","\t\tif ( fullName.indexOf( filter ) !== -1 ) {","\t\t\treturn include;","\t\t}","","\t\t// Otherwise, do the opposite","\t\treturn !include;","\t}","","};","","// Resets the test setup. Useful for tests that modify the DOM.","/*","DEPRECATED: Use multiple tests instead of resetting inside a test.","Use testStart or testDone for custom cleanup.","This method will throw an error in 2.0, and will be removed in 2.1","*/","QUnit.reset = function() {","","\t// Return on non-browser environments","\t// This is necessary to not break on node tests","\tif ( typeof window === \"undefined\" ) {","\t\treturn;","\t}","","\tvar fixture = defined.document && document.getElementById &&","\t\t\tdocument.getElementById( \"qunit-fixture\" );","","\tif ( fixture ) {","\t\tfixture.innerHTML = config.fixture;","\t}","};","","QUnit.pushFailure = function() {","\tif ( !QUnit.config.current ) {","\t\tthrow new Error( \"pushFailure() assertion outside test context, in \" +","\t\t\tsourceFromStacktrace( 2 ) );","\t}","","\t// Gets current test obj","\tvar currentTest = QUnit.config.current;","","\treturn currentTest.pushFailure.apply( currentTest, arguments );","};","","// Based on Java's String.hashCode, a simple but not","// rigorously collision resistant hashing function","function generateHash( module, testName ) {","\tvar hex,","\t\ti = 0,","\t\thash = 0,","\t\tstr = module + \"\\x1C\" + testName,","\t\tlen = str.length;","","\tfor ( ; i < len; i++ ) {","\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );","\t\thash |= 0;","\t}","","\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn't","\t// strictly necessary but increases user understanding that the id is a SHA-like hash","\thex = ( 0x100000000 + hash ).toString( 16 );","\tif ( hex.length < 8 ) {","\t\thex = \"0000000\" + hex;","\t}","","\treturn hex.slice( -8 );","}","","function Assert( testContext ) {","\tthis.test = testContext;","}","","// Assert helpers","QUnit.assert = Assert.prototype = {","","\t// Specify the number of expected assertions to guarantee that failed test","\t// (no assertions are run at all) don't slip through.","\texpect: function( asserts ) {","\t\tif ( arguments.length === 1 ) {","\t\t\tthis.test.expected = asserts;","\t\t} else {","\t\t\treturn this.test.expected;","\t\t}","\t},","","\t// Increment this Test's semaphore counter, then return a single-use function that","\t// decrements that counter a maximum of once.","\tasync: function() {","\t\tvar test = this.test,","\t\t\tpopped = false;","","\t\ttest.semaphore += 1;","\t\ttest.usedAsync = true;","\t\tpauseProcessing();","","\t\treturn function done() {","\t\t\tif ( !popped ) {","\t\t\t\ttest.semaphore -= 1;","\t\t\t\tpopped = true;","\t\t\t\tresumeProcessing();","\t\t\t} else {","\t\t\t\ttest.pushFailure( \"Called the callback returned from `assert.async` more than once\",","\t\t\t\t\tsourceFromStacktrace( 2 ) );","\t\t\t}","\t\t};","\t},","","\t// Exports test.push() to the user API","\tpush: function( /* result, actual, expected, message */ ) {","\t\tvar assert = this,","\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;","","\t\t// Backwards compatibility fix.","\t\t// Allows the direct use of global exported assertions and QUnit.assert.*","\t\t// Although, it's use is not recommended as it can leak assertions","\t\t// to other tests from async tests, because we only get a reference to the current test,","\t\t// not exactly the test where assertion were intended to be called.","\t\tif ( !currentTest ) {","\t\t\tthrow new Error( \"assertion outside test context, in \" + sourceFromStacktrace( 2 ) );","\t\t}","","\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {","\t\t\tcurrentTest.pushFailure( \"Assertion after the final `assert.async` was resolved\",","\t\t\t\tsourceFromStacktrace( 2 ) );","","\t\t\t// Allow this assertion to continue running anyway...","\t\t}","","\t\tif ( !( assert instanceof Assert ) ) {","\t\t\tassert = currentTest.assert;","\t\t}","\t\treturn assert.test.push.apply( assert.test, arguments );","\t},","","\t/**","\t * Asserts rough true-ish result.","\t * @name ok","\t * @function","\t * @example ok( \"asdfasdf\".length > 5, \"There must be at least 5 chars\" );","\t */","\tok: function( result, message ) {","\t\tmessage = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +","\t\t\tQUnit.dump.parse( result ) );","\t\tthis.push( !!result, result, true, message );","\t},","","\t/**","\t * Assert that the first two arguments are equal, with an optional message.","\t * Prints out both actual and expected values.","\t * @name equal","\t * @function","\t * @example equal( format( \"{0} bytes.\", 2), \"2 bytes.\", \"replaces {0} with next argument\" );","\t */","\tequal: function( actual, expected, message ) {","\t\t/*jshint eqeqeq:false */","\t\tthis.push( expected == actual, actual, expected, message );","\t},","","\t/**","\t * @name notEqual","\t * @function","\t */","\tnotEqual: function( actual, expected, message ) {","\t\t/*jshint eqeqeq:false */","\t\tthis.push( expected != actual, actual, expected, message );","\t},","","\t/**","\t * @name propEqual","\t * @function","\t */","\tpropEqual: function( actual, expected, message ) {","\t\tactual = objectValues( actual );","\t\texpected = objectValues( expected );","\t\tthis.push( QUnit.equiv( actual, expected ), actual, expected, message );","\t},","","\t/**","\t * @name notPropEqual","\t * @function","\t */","\tnotPropEqual: function( actual, expected, message ) {","\t\tactual = objectValues( actual );","\t\texpected = objectValues( expected );","\t\tthis.push( !QUnit.equiv( actual, expected ), actual, expected, message );","\t},","","\t/**","\t * @name deepEqual","\t * @function","\t */","\tdeepEqual: function( actual, expected, message ) {","\t\tthis.push( QUnit.equiv( actual, expected ), actual, expected, message );","\t},","","\t/**","\t * @name notDeepEqual","\t * @function","\t */","\tnotDeepEqual: function( actual, expected, message ) {","\t\tthis.push( !QUnit.equiv( actual, expected ), actual, expected, message );","\t},","","\t/**","\t * @name strictEqual","\t * @function","\t */","\tstrictEqual: function( actual, expected, message ) {","\t\tthis.push( expected === actual, actual, expected, message );","\t},","","\t/**","\t * @name notStrictEqual","\t * @function","\t */","\tnotStrictEqual: function( actual, expected, message ) {","\t\tthis.push( expected !== actual, actual, expected, message );","\t},","","\t\"throws\": function( block, expected, message ) {","\t\tvar actual, expectedType,","\t\t\texpectedOutput = expected,","\t\t\tok = false;","","\t\t// 'expected' is optional unless doing string comparison","\t\tif ( message == null && typeof expected === \"string\" ) {","\t\t\tmessage = expected;","\t\t\texpected = null;","\t\t}","","\t\tthis.test.ignoreGlobalErrors = true;","\t\ttry {","\t\t\tblock.call( this.test.testEnvironment );","\t\t} catch (e) {","\t\t\tactual = e;","\t\t}","\t\tthis.test.ignoreGlobalErrors = false;","","\t\tif ( actual ) {","\t\t\texpectedType = QUnit.objectType( expected );","","\t\t\t// we don't want to validate thrown error","\t\t\tif ( !expected ) {","\t\t\t\tok = true;","\t\t\t\texpectedOutput = null;","","\t\t\t// expected is a regexp","\t\t\t} else if ( expectedType === \"regexp\" ) {","\t\t\t\tok = expected.test( errorString( actual ) );","","\t\t\t// expected is a string","\t\t\t} else if ( expectedType === \"string\" ) {","\t\t\t\tok = expected === errorString( actual );","","\t\t\t// expected is a constructor, maybe an Error constructor","\t\t\t} else if ( expectedType === \"function\" && actual instanceof expected ) {","\t\t\t\tok = true;","","\t\t\t// expected is an Error object","\t\t\t} else if ( expectedType === \"object\" ) {","\t\t\t\tok = actual instanceof expected.constructor &&","\t\t\t\t\tactual.name === expected.name &&","\t\t\t\t\tactual.message === expected.message;","","\t\t\t// expected is a validation function which returns true if validation passed","\t\t\t} else if ( expectedType === \"function\" && expected.call( {}, actual ) === true ) {","\t\t\t\texpectedOutput = null;","\t\t\t\tok = true;","\t\t\t}","","\t\t\tthis.push( ok, actual, expectedOutput, message );","\t\t} else {","\t\t\tthis.test.pushFailure( message, null, \"No exception was thrown.\" );","\t\t}","\t}","};","","// Provide an alternative to assert.throws(), for enviroments that consider throws a reserved word","// Known to us are: Closure Compiler, Narwhal","(function() {","\t/*jshint sub:true */","\tAssert.prototype.raises = Assert.prototype[ \"throws\" ];","}());","","// Test for equality any JavaScript type.","// Author: Philippe RathÃ© <prathe@gmail.com>","QUnit.equiv = (function() {","","\t// Call the o related callback with the given arguments.","\tfunction bindCallbacks( o, callbacks, args ) {","\t\tvar prop = QUnit.objectType( o );","\t\tif ( prop ) {","\t\t\tif ( QUnit.objectType( callbacks[ prop ] ) === \"function\" ) {","\t\t\t\treturn callbacks[ prop ].apply( callbacks, args );","\t\t\t} else {","\t\t\t\treturn callbacks[ prop ]; // or undefined","\t\t\t}","\t\t}","\t}","","\t// the real equiv function","\tvar innerEquiv,","","\t\t// stack to decide between skip/abort functions","\t\tcallers = [],","","\t\t// stack to avoiding loops from circular referencing","\t\tparents = [],","\t\tparentsB = [],","","\t\tgetProto = Object.getPrototypeOf || function( obj ) {","\t\t\t/* jshint camelcase: false, proto: true */","\t\t\treturn obj.__proto__;","\t\t},","\t\tcallbacks = (function() {","","\t\t\t// for string, boolean, number and null","\t\t\tfunction useStrictEquality( b, a ) {","","\t\t\t\t/*jshint eqeqeq:false */","\t\t\t\tif ( b instanceof a.constructor || a instanceof b.constructor ) {","","\t\t\t\t\t// to catch short annotation VS 'new' annotation of a","\t\t\t\t\t// declaration","\t\t\t\t\t// e.g. var i = 1;","\t\t\t\t\t// var j = new Number(1);","\t\t\t\t\treturn a == b;","\t\t\t\t} else {","\t\t\t\t\treturn a === b;","\t\t\t\t}","\t\t\t}","","\t\t\treturn {","\t\t\t\t\"string\": useStrictEquality,","\t\t\t\t\"boolean\": useStrictEquality,","\t\t\t\t\"number\": useStrictEquality,","\t\t\t\t\"null\": useStrictEquality,","\t\t\t\t\"undefined\": useStrictEquality,","","\t\t\t\t\"nan\": function( b ) {","\t\t\t\t\treturn isNaN( b );","\t\t\t\t},","","\t\t\t\t\"date\": function( b, a ) {","\t\t\t\t\treturn QUnit.objectType( b ) === \"date\" && a.valueOf() === b.valueOf();","\t\t\t\t},","","\t\t\t\t\"regexp\": function( b, a ) {","\t\t\t\t\treturn QUnit.objectType( b ) === \"regexp\" &&","","\t\t\t\t\t\t// the regex itself","\t\t\t\t\t\ta.source === b.source &&","","\t\t\t\t\t\t// and its modifiers","\t\t\t\t\t\ta.global === b.global &&","","\t\t\t\t\t\t// (gmi) ...","\t\t\t\t\t\ta.ignoreCase === b.ignoreCase &&","\t\t\t\t\t\ta.multiline === b.multiline &&","\t\t\t\t\t\ta.sticky === b.sticky;","\t\t\t\t},","","\t\t\t\t// - skip when the property is a method of an instance (OOP)","\t\t\t\t// - abort otherwise,","\t\t\t\t// initial === would have catch identical references anyway","\t\t\t\t\"function\": function() {","\t\t\t\t\tvar caller = callers[ callers.length - 1 ];","\t\t\t\t\treturn caller !== Object && typeof caller !== \"undefined\";","\t\t\t\t},","","\t\t\t\t\"array\": function( b, a ) {","\t\t\t\t\tvar i, j, len, loop, aCircular, bCircular;","","\t\t\t\t\t// b could be an object literal here","\t\t\t\t\tif ( QUnit.objectType( b ) !== \"array\" ) {","\t\t\t\t\t\treturn false;","\t\t\t\t\t}","","\t\t\t\t\tlen = a.length;","\t\t\t\t\tif ( len !== b.length ) {","\t\t\t\t\t\t// safe and faster","\t\t\t\t\t\treturn false;","\t\t\t\t\t}","","\t\t\t\t\t// track reference to avoid circular references","\t\t\t\t\tparents.push( a );","\t\t\t\t\tparentsB.push( b );","\t\t\t\t\tfor ( i = 0; i < len; i++ ) {","\t\t\t\t\t\tloop = false;","\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {","\t\t\t\t\t\t\taCircular = parents[ j ] === a[ i ];","\t\t\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];","\t\t\t\t\t\t\tif ( aCircular || bCircular ) {","\t\t\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {","\t\t\t\t\t\t\t\t\tloop = true;","\t\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\t\tparents.pop();","\t\t\t\t\t\t\t\t\tparentsB.pop();","\t\t\t\t\t\t\t\t\treturn false;","\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {","\t\t\t\t\t\t\tparents.pop();","\t\t\t\t\t\t\tparentsB.pop();","\t\t\t\t\t\t\treturn false;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\tparents.pop();","\t\t\t\t\tparentsB.pop();","\t\t\t\t\treturn true;","\t\t\t\t},","","\t\t\t\t\"object\": function( b, a ) {","","\t\t\t\t\t/*jshint forin:false */","\t\t\t\t\tvar i, j, loop, aCircular, bCircular,","\t\t\t\t\t\t// Default to true","\t\t\t\t\t\teq = true,","\t\t\t\t\t\taProperties = [],","\t\t\t\t\t\tbProperties = [];","","\t\t\t\t\t// comparing constructors is more strict than using","\t\t\t\t\t// instanceof","\t\t\t\t\tif ( a.constructor !== b.constructor ) {","","\t\t\t\t\t\t// Allow objects with no prototype to be equivalent to","\t\t\t\t\t\t// objects with Object as their constructor.","\t\t\t\t\t\tif ( !( ( getProto( a ) === null && getProto( b ) === Object.prototype ) ||","\t\t\t\t\t\t\t( getProto( b ) === null && getProto( a ) === Object.prototype ) ) ) {","\t\t\t\t\t\t\treturn false;","\t\t\t\t\t\t}","\t\t\t\t\t}","","\t\t\t\t\t// stack constructor before traversing properties","\t\t\t\t\tcallers.push( a.constructor );","","\t\t\t\t\t// track reference to avoid circular references","\t\t\t\t\tparents.push( a );","\t\t\t\t\tparentsB.push( b );","","\t\t\t\t\t// be strict: don't ensure hasOwnProperty and go deep","\t\t\t\t\tfor ( i in a ) {","\t\t\t\t\t\tloop = false;","\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {","\t\t\t\t\t\t\taCircular = parents[ j ] === a[ i ];","\t\t\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];","\t\t\t\t\t\t\tif ( aCircular || bCircular ) {","\t\t\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {","\t\t\t\t\t\t\t\t\tloop = true;","\t\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\t\teq = false;","\t\t\t\t\t\t\t\t\tbreak;","\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t\taProperties.push( i );","\t\t\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {","\t\t\t\t\t\t\teq = false;","\t\t\t\t\t\t\tbreak;","\t\t\t\t\t\t}","\t\t\t\t\t}","","\t\t\t\t\tparents.pop();","\t\t\t\t\tparentsB.pop();","\t\t\t\t\tcallers.pop(); // unstack, we are done","","\t\t\t\t\tfor ( i in b ) {","\t\t\t\t\t\tbProperties.push( i ); // collect b's properties","\t\t\t\t\t}","","\t\t\t\t\t// Ensures identical properties name","\t\t\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );","\t\t\t\t}","\t\t\t};","\t\t}());","","\tinnerEquiv = function() { // can take multiple arguments","\t\tvar args = [].slice.apply( arguments );","\t\tif ( args.length < 2 ) {","\t\t\treturn true; // end transition","\t\t}","","\t\treturn ( (function( a, b ) {","\t\t\tif ( a === b ) {","\t\t\t\treturn true; // catch the most you can","\t\t\t} else if ( a === null || b === null || typeof a === \"undefined\" ||","\t\t\t\t\ttypeof b === \"undefined\" ||","\t\t\t\t\tQUnit.objectType( a ) !== QUnit.objectType( b ) ) {","","\t\t\t\t// don't lose time with error prone cases","\t\t\t\treturn false;","\t\t\t} else {","\t\t\t\treturn bindCallbacks( a, callbacks, [ b, a ] );","\t\t\t}","","\t\t\t// apply transition with (1..n) arguments","\t\t}( args[ 0 ], args[ 1 ] ) ) &&","\t\t\tinnerEquiv.apply( this, args.splice( 1, args.length - 1 ) ) );","\t};","","\treturn innerEquiv;","}());","","// Based on jsDump by Ariel Flesler","// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html","QUnit.dump = (function() {","\tfunction quote( str ) {","\t\treturn \"\\\"\" + str.toString().replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";","\t}","\tfunction literal( o ) {","\t\treturn o + \"\";","\t}","\tfunction join( pre, arr, post ) {","\t\tvar s = dump.separator(),","\t\t\tbase = dump.indent(),","\t\t\tinner = dump.indent( 1 );","\t\tif ( arr.join ) {","\t\t\tarr = arr.join( \",\" + s + inner );","\t\t}","\t\tif ( !arr ) {","\t\t\treturn pre + post;","\t\t}","\t\treturn [ pre, inner + arr, base + post ].join( s );","\t}","\tfunction array( arr, stack ) {","\t\tvar i = arr.length,","\t\t\tret = new Array( i );","","\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {","\t\t\treturn \"[object Array]\";","\t\t}","","\t\tthis.up();","\t\twhile ( i-- ) {","\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );","\t\t}","\t\tthis.down();","\t\treturn join( \"[\", ret, \"]\" );","\t}","","\tvar reName = /^function (\\w+)/,","\t\tdump = {","","\t\t\t// objType is used mostly internally, you can fix a (custom) type in advance","\t\t\tparse: function( obj, objType, stack ) {","\t\t\t\tstack = stack || [];","\t\t\t\tvar res, parser, parserType,","\t\t\t\t\tinStack = inArray( obj, stack );","","\t\t\t\tif ( inStack !== -1 ) {","\t\t\t\t\treturn \"recursion(\" + ( inStack - stack.length ) + \")\";","\t\t\t\t}","","\t\t\t\tobjType = objType || this.typeOf( obj  );","\t\t\t\tparser = this.parsers[ objType ];","\t\t\t\tparserType = typeof parser;","","\t\t\t\tif ( parserType === \"function\" ) {","\t\t\t\t\tstack.push( obj );","\t\t\t\t\tres = parser.call( this, obj, stack );","\t\t\t\t\tstack.pop();","\t\t\t\t\treturn res;","\t\t\t\t}","\t\t\t\treturn ( parserType === \"string\" ) ? parser : this.parsers.error;","\t\t\t},","\t\t\ttypeOf: function( obj ) {","\t\t\t\tvar type;","\t\t\t\tif ( obj === null ) {","\t\t\t\t\ttype = \"null\";","\t\t\t\t} else if ( typeof obj === \"undefined\" ) {","\t\t\t\t\ttype = \"undefined\";","\t\t\t\t} else if ( QUnit.is( \"regexp\", obj ) ) {","\t\t\t\t\ttype = \"regexp\";","\t\t\t\t} else if ( QUnit.is( \"date\", obj ) ) {","\t\t\t\t\ttype = \"date\";","\t\t\t\t} else if ( QUnit.is( \"function\", obj ) ) {","\t\t\t\t\ttype = \"function\";","\t\t\t\t} else if ( obj.setInterval !== undefined &&","\t\t\t\t\t\tobj.document !== undefined &&","\t\t\t\t\t\tobj.nodeType === undefined ) {","\t\t\t\t\ttype = \"window\";","\t\t\t\t} else if ( obj.nodeType === 9 ) {","\t\t\t\t\ttype = \"document\";","\t\t\t\t} else if ( obj.nodeType ) {","\t\t\t\t\ttype = \"node\";","\t\t\t\t} else if (","","\t\t\t\t\t// native arrays","\t\t\t\t\ttoString.call( obj ) === \"[object Array]\" ||","","\t\t\t\t\t// NodeList objects","\t\t\t\t\t( typeof obj.length === \"number\" && obj.item !== undefined &&","\t\t\t\t\t( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&","\t\t\t\t\tobj[ 0 ] === undefined ) ) )","\t\t\t\t) {","\t\t\t\t\ttype = \"array\";","\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {","\t\t\t\t\ttype = \"error\";","\t\t\t\t} else {","\t\t\t\t\ttype = typeof obj;","\t\t\t\t}","\t\t\t\treturn type;","\t\t\t},","\t\t\tseparator: function() {","\t\t\t\treturn this.multiline ? this.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&#160;\" : \" \";","\t\t\t},","\t\t\t// extra can be a number, shortcut for increasing-calling-decreasing","\t\t\tindent: function( extra ) {","\t\t\t\tif ( !this.multiline ) {","\t\t\t\t\treturn \"\";","\t\t\t\t}","\t\t\t\tvar chr = this.indentChar;","\t\t\t\tif ( this.HTML ) {","\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&#160;\" );","\t\t\t\t}","\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );","\t\t\t},","\t\t\tup: function( a ) {","\t\t\t\tthis.depth += a || 1;","\t\t\t},","\t\t\tdown: function( a ) {","\t\t\t\tthis.depth -= a || 1;","\t\t\t},","\t\t\tsetParser: function( name, parser ) {","\t\t\t\tthis.parsers[ name ] = parser;","\t\t\t},","\t\t\t// The next 3 are exposed so you can use them","\t\t\tquote: quote,","\t\t\tliteral: literal,","\t\t\tjoin: join,","\t\t\t//","\t\t\tdepth: 1,","\t\t\tmaxDepth: 5,","","\t\t\t// This is the list of parsers, to modify them, use dump.setParser","\t\t\tparsers: {","\t\t\t\twindow: \"[Window]\",","\t\t\t\tdocument: \"[Document]\",","\t\t\t\terror: function( error ) {","\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";","\t\t\t\t},","\t\t\t\tunknown: \"[Unknown]\",","\t\t\t\t\"null\": \"null\",","\t\t\t\t\"undefined\": \"undefined\",","\t\t\t\t\"function\": function( fn ) {","\t\t\t\t\tvar ret = \"function\",","","\t\t\t\t\t\t// functions never have name in IE","\t\t\t\t\t\tname = \"name\" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];","","\t\t\t\t\tif ( name ) {","\t\t\t\t\t\tret += \" \" + name;","\t\t\t\t\t}","\t\t\t\t\tret += \"( \";","","\t\t\t\t\tret = [ ret, dump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );","\t\t\t\t\treturn join( ret, dump.parse( fn, \"functionCode\" ), \"}\" );","\t\t\t\t},","\t\t\t\tarray: array,","\t\t\t\tnodelist: array,","\t\t\t\t\"arguments\": array,","\t\t\t\tobject: function( map, stack ) {","\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,","\t\t\t\t\t\tret = [];","","\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {","\t\t\t\t\t\treturn \"[object Object]\";","\t\t\t\t\t}","","\t\t\t\t\tdump.up();","\t\t\t\t\tkeys = [];","\t\t\t\t\tfor ( key in map ) {","\t\t\t\t\t\tkeys.push( key );","\t\t\t\t\t}","","\t\t\t\t\t// Some properties are not always enumerable on Error objects.","\t\t\t\t\tnonEnumerableProperties = [ \"message\", \"name\" ];","\t\t\t\t\tfor ( i in nonEnumerableProperties ) {","\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];","\t\t\t\t\t\tif ( key in map && !( key in keys ) ) {","\t\t\t\t\t\t\tkeys.push( key );","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\tkeys.sort();","\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {","\t\t\t\t\t\tkey = keys[ i ];","\t\t\t\t\t\tval = map[ key ];","\t\t\t\t\t\tret.push( dump.parse( key, \"key\" ) + \": \" +","\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );","\t\t\t\t\t}","\t\t\t\t\tdump.down();","\t\t\t\t\treturn join( \"{\", ret, \"}\" );","\t\t\t\t},","\t\t\t\tnode: function( node ) {","\t\t\t\t\tvar len, i, val,","\t\t\t\t\t\topen = dump.HTML ? \"&lt;\" : \"<\",","\t\t\t\t\t\tclose = dump.HTML ? \"&gt;\" : \">\",","\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),","\t\t\t\t\t\tret = open + tag,","\t\t\t\t\t\tattrs = node.attributes;","","\t\t\t\t\tif ( attrs ) {","\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {","\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;","","\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly","\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, \"\" or","\t\t\t\t\t\t\t// \"inherit\".","\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {","\t\t\t\t\t\t\t\tret += \" \" + attrs[ i ].nodeName + \"=\" +","\t\t\t\t\t\t\t\t\tdump.parse( val, \"attribute\" );","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\tret += close;","","\t\t\t\t\t// Show content of TextNode or CDATASection","\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {","\t\t\t\t\t\tret += node.nodeValue;","\t\t\t\t\t}","","\t\t\t\t\treturn ret + open + \"/\" + tag + close;","\t\t\t\t},","","\t\t\t\t// function calls it internally, it's the arguments part of the function","\t\t\t\tfunctionArgs: function( fn ) {","\t\t\t\t\tvar args,","\t\t\t\t\t\tl = fn.length;","","\t\t\t\t\tif ( !l ) {","\t\t\t\t\t\treturn \"\";","\t\t\t\t\t}","","\t\t\t\t\targs = new Array( l );","\t\t\t\t\twhile ( l-- ) {","","\t\t\t\t\t\t// 97 is 'a'","\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );","\t\t\t\t\t}","\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";","\t\t\t\t},","\t\t\t\t// object calls it internally, the key part of an item in a map","\t\t\t\tkey: quote,","\t\t\t\t// function calls it internally, it's the content of the function","\t\t\t\tfunctionCode: \"[code]\",","\t\t\t\t// node calls it internally, it's an html attribute value","\t\t\t\tattribute: quote,","\t\t\t\tstring: quote,","\t\t\t\tdate: quote,","\t\t\t\tregexp: literal,","\t\t\t\tnumber: literal,","\t\t\t\t\"boolean\": literal","\t\t\t},","\t\t\t// if true, entities are escaped ( <, >, \\t, space and \\n )","\t\t\tHTML: false,","\t\t\t// indentation unit","\t\t\tindentChar: \"  \",","\t\t\t// if true, items in a collection, are separated by a \\n, else just a space.","\t\t\tmultiline: true","\t\t};","","\treturn dump;","}());","","// back compat","QUnit.jsDump = QUnit.dump;","","// For browser, export only select globals","if ( typeof window !== \"undefined\" ) {","","\t// Deprecated","\t// Extend assert methods to QUnit and Global scope through Backwards compatibility","\t(function() {","\t\tvar i,","\t\t\tassertions = Assert.prototype;","","\t\tfunction applyCurrent( current ) {","\t\t\treturn function() {","\t\t\t\tvar assert = new Assert( QUnit.config.current );","\t\t\t\tcurrent.apply( assert, arguments );","\t\t\t};","\t\t}","","\t\tfor ( i in assertions ) {","\t\t\tQUnit[ i ] = applyCurrent( assertions[ i ] );","\t\t}","\t})();","","\t(function() {","\t\tvar i, l,","\t\t\tkeys = [","\t\t\t\t\"test\",","\t\t\t\t\"module\",","\t\t\t\t\"expect\",","\t\t\t\t\"asyncTest\",","\t\t\t\t\"start\",","\t\t\t\t\"stop\",","\t\t\t\t\"ok\",","\t\t\t\t\"equal\",","\t\t\t\t\"notEqual\",","\t\t\t\t\"propEqual\",","\t\t\t\t\"notPropEqual\",","\t\t\t\t\"deepEqual\",","\t\t\t\t\"notDeepEqual\",","\t\t\t\t\"strictEqual\",","\t\t\t\t\"notStrictEqual\",","\t\t\t\t\"throws\"","\t\t\t];","","\t\tfor ( i = 0, l = keys.length; i < l; i++ ) {","\t\t\twindow[ keys[ i ] ] = QUnit[ keys[ i ] ];","\t\t}","\t})();","","\twindow.QUnit = QUnit;","}","","// For nodejs","if ( typeof module !== \"undefined\" && module.exports ) {","\tmodule.exports = QUnit;","}","","// For CommonJS with exports, but without module.exports, like Rhino","if ( typeof exports !== \"undefined\" ) {","\texports.QUnit = QUnit;","}","","// Get a reference to the global object, like window in browsers","}( (function() {","\treturn this;","})() ));","","/*istanbul ignore next */","// jscs:disable maximumLineLength","/*"," * Javascript Diff Algorithm"," *  By John Resig (http://ejohn.org/)"," *  Modified by Chu Alan \"sprite\""," *"," * Released under the MIT license."," *"," * More Info:"," *  http://ejohn.org/projects/javascript-diff-algorithm/"," *"," * Usage: QUnit.diff(expected, actual)"," *"," * QUnit.diff( \"the quick brown fox jumped over\", \"the quick fox jumps over\" ) == \"the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over\""," */","QUnit.diff = (function() {","\tvar hasOwn = Object.prototype.hasOwnProperty;","","\t/*jshint eqeqeq:false, eqnull:true */","\tfunction diff( o, n ) {","\t\tvar i,","\t\t\tns = {},","\t\t\tos = {};","","\t\tfor ( i = 0; i < n.length; i++ ) {","\t\t\tif ( !hasOwn.call( ns, n[ i ] ) ) {","\t\t\t\tns[ n[ i ] ] = {","\t\t\t\t\trows: [],","\t\t\t\t\to: null","\t\t\t\t};","\t\t\t}","\t\t\tns[ n[ i ] ].rows.push( i );","\t\t}","","\t\tfor ( i = 0; i < o.length; i++ ) {","\t\t\tif ( !hasOwn.call( os, o[ i ] ) ) {","\t\t\t\tos[ o[ i ] ] = {","\t\t\t\t\trows: [],","\t\t\t\t\tn: null","\t\t\t\t};","\t\t\t}","\t\t\tos[ o[ i ] ].rows.push( i );","\t\t}","","\t\tfor ( i in ns ) {","\t\t\tif ( hasOwn.call( ns, i ) ) {","\t\t\t\tif ( ns[ i ].rows.length === 1 && hasOwn.call( os, i ) && os[ i ].rows.length === 1 ) {","\t\t\t\t\tn[ ns[ i ].rows[ 0 ] ] = {","\t\t\t\t\t\ttext: n[ ns[ i ].rows[ 0 ] ],","\t\t\t\t\t\trow: os[ i ].rows[ 0 ]","\t\t\t\t\t};","\t\t\t\t\to[ os[ i ].rows[ 0 ] ] = {","\t\t\t\t\t\ttext: o[ os[ i ].rows[ 0 ] ],","\t\t\t\t\t\trow: ns[ i ].rows[ 0 ]","\t\t\t\t\t};","\t\t\t\t}","\t\t\t}","\t\t}","","\t\tfor ( i = 0; i < n.length - 1; i++ ) {","\t\t\tif ( n[ i ].text != null && n[ i + 1 ].text == null && n[ i ].row + 1 < o.length && o[ n[ i ].row + 1 ].text == null &&","\t\t\t\tn[ i + 1 ] == o[ n[ i ].row + 1 ] ) {","","\t\t\t\tn[ i + 1 ] = {","\t\t\t\t\ttext: n[ i + 1 ],","\t\t\t\t\trow: n[ i ].row + 1","\t\t\t\t};","\t\t\t\to[ n[ i ].row + 1 ] = {","\t\t\t\t\ttext: o[ n[ i ].row + 1 ],","\t\t\t\t\trow: i + 1","\t\t\t\t};","\t\t\t}","\t\t}","","\t\tfor ( i = n.length - 1; i > 0; i-- ) {","\t\t\tif ( n[ i ].text != null && n[ i - 1 ].text == null && n[ i ].row > 0 && o[ n[ i ].row - 1 ].text == null &&","\t\t\t\tn[ i - 1 ] == o[ n[ i ].row - 1 ] ) {","","\t\t\t\tn[ i - 1 ] = {","\t\t\t\t\ttext: n[ i - 1 ],","\t\t\t\t\trow: n[ i ].row - 1","\t\t\t\t};","\t\t\t\to[ n[ i ].row - 1 ] = {","\t\t\t\t\ttext: o[ n[ i ].row - 1 ],","\t\t\t\t\trow: i - 1","\t\t\t\t};","\t\t\t}","\t\t}","","\t\treturn {","\t\t\to: o,","\t\t\tn: n","\t\t};","\t}","","\treturn function( o, n ) {","\t\to = o.replace( /\\s+$/, \"\" );","\t\tn = n.replace( /\\s+$/, \"\" );","","\t\tvar i, pre,","\t\t\tstr = \"\",","\t\t\tout = diff( o === \"\" ? [] : o.split( /\\s+/ ), n === \"\" ? [] : n.split( /\\s+/ ) ),","\t\t\toSpace = o.match( /\\s+/g ),","\t\t\tnSpace = n.match( /\\s+/g );","","\t\tif ( oSpace == null ) {","\t\t\toSpace = [ \" \" ];","\t\t} else {","\t\t\toSpace.push( \" \" );","\t\t}","","\t\tif ( nSpace == null ) {","\t\t\tnSpace = [ \" \" ];","\t\t} else {","\t\t\tnSpace.push( \" \" );","\t\t}","","\t\tif ( out.n.length === 0 ) {","\t\t\tfor ( i = 0; i < out.o.length; i++ ) {","\t\t\t\tstr += \"<del>\" + out.o[ i ] + oSpace[ i ] + \"</del>\";","\t\t\t}","\t\t} else {","\t\t\tif ( out.n[ 0 ].text == null ) {","\t\t\t\tfor ( n = 0; n < out.o.length && out.o[ n ].text == null; n++ ) {","\t\t\t\t\tstr += \"<del>\" + out.o[ n ] + oSpace[ n ] + \"</del>\";","\t\t\t\t}","\t\t\t}","","\t\t\tfor ( i = 0; i < out.n.length; i++ ) {","\t\t\t\tif ( out.n[ i ].text == null ) {","\t\t\t\t\tstr += \"<ins>\" + out.n[ i ] + nSpace[ i ] + \"</ins>\";","\t\t\t\t} else {","","\t\t\t\t\t// `pre` initialized at top of scope","\t\t\t\t\tpre = \"\";","","\t\t\t\t\tfor ( n = out.n[ i ].row + 1; n < out.o.length && out.o[ n ].text == null; n++ ) {","\t\t\t\t\t\tpre += \"<del>\" + out.o[ n ] + oSpace[ n ] + \"</del>\";","\t\t\t\t\t}","\t\t\t\t\tstr += \" \" + out.n[ i ].text + nSpace[ i ] + pre;","\t\t\t\t}","\t\t\t}","\t\t}","","\t\treturn str;","\t};","}());","// jscs:enable","","(function() {","","// Deprecated QUnit.init - Ref #530","// Re-initialize the configuration options","QUnit.init = function() {","\tvar tests, banner, result, qunit,","\t\tconfig = QUnit.config;","","\tconfig.stats = { all: 0, bad: 0 };","\tconfig.moduleStats = { all: 0, bad: 0 };","\tconfig.started = 0;","\tconfig.updateRate = 1000;","\tconfig.blocking = false;","\tconfig.autostart = true;","\tconfig.autorun = false;","\tconfig.filter = \"\";","\tconfig.queue = [];","","\t// Return on non-browser environments","\t// This is necessary to not break on node tests","\tif ( typeof window === \"undefined\" ) {","\t\treturn;","\t}","","\tqunit = id( \"qunit\" );","\tif ( qunit ) {","\t\tqunit.innerHTML =","\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +","\t\t\t\"<h2 id='qunit-banner'></h2>\" +","\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +","\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +","\t\t\t\"<ol id='qunit-tests'></ol>\";","\t}","","\ttests = id( \"qunit-tests\" );","\tbanner = id( \"qunit-banner\" );","\tresult = id( \"qunit-testresult\" );","","\tif ( tests ) {","\t\ttests.innerHTML = \"\";","\t}","","\tif ( banner ) {","\t\tbanner.className = \"\";","\t}","","\tif ( result ) {","\t\tresult.parentNode.removeChild( result );","\t}","","\tif ( tests ) {","\t\tresult = document.createElement( \"p\" );","\t\tresult.id = \"qunit-testresult\";","\t\tresult.className = \"result\";","\t\ttests.parentNode.insertBefore( result, tests );","\t\tresult.innerHTML = \"Running...<br />&#160;\";","\t}","};","","// Don't load the HTML Reporter on non-Browser environments","if ( typeof window === \"undefined\" ) {","\treturn;","}","","var config = QUnit.config,","\thasOwn = Object.prototype.hasOwnProperty,","\tdefined = {","\t\tdocument: window.document !== undefined,","\t\tsessionStorage: (function() {","\t\t\tvar x = \"qunit-test-string\";","\t\t\ttry {","\t\t\t\tsessionStorage.setItem( x, x );","\t\t\t\tsessionStorage.removeItem( x );","\t\t\t\treturn true;","\t\t\t} catch ( e ) {","\t\t\t\treturn false;","\t\t\t}","\t\t}())","\t},","\tmodulesList = [];","","/**","* Escape text for attribute or text content.","*/","function escapeText( s ) {","\tif ( !s ) {","\t\treturn \"\";","\t}","\ts = s + \"\";","","\t// Both single quotes and double quotes (for attributes)","\treturn s.replace( /['\"<>&]/g, function( s ) {","\t\tswitch ( s ) {","\t\tcase \"'\":","\t\t\treturn \"&#039;\";","\t\tcase \"\\\"\":","\t\t\treturn \"&quot;\";","\t\tcase \"<\":","\t\t\treturn \"&lt;\";","\t\tcase \">\":","\t\t\treturn \"&gt;\";","\t\tcase \"&\":","\t\t\treturn \"&amp;\";","\t\t}","\t});","}","","/**"," * @param {HTMLElement} elem"," * @param {string} type"," * @param {Function} fn"," */","function addEvent( elem, type, fn ) {","\tif ( elem.addEventListener ) {","","\t\t// Standards-based browsers","\t\telem.addEventListener( type, fn, false );","\t} else if ( elem.attachEvent ) {","","\t\t// support: IE <9","\t\telem.attachEvent( \"on\" + type, fn );","\t}","}","","/**"," * @param {Array|NodeList} elems"," * @param {string} type"," * @param {Function} fn"," */","function addEvents( elems, type, fn ) {","\tvar i = elems.length;","\twhile ( i-- ) {","\t\taddEvent( elems[ i ], type, fn );","\t}","}","","function hasClass( elem, name ) {","\treturn ( \" \" + elem.className + \" \" ).indexOf( \" \" + name + \" \" ) >= 0;","}","","function addClass( elem, name ) {","\tif ( !hasClass( elem, name ) ) {","\t\telem.className += ( elem.className ? \" \" : \"\" ) + name;","\t}","}","","function toggleClass( elem, name ) {","\tif ( hasClass( elem, name ) ) {","\t\tremoveClass( elem, name );","\t} else {","\t\taddClass( elem, name );","\t}","}","","function removeClass( elem, name ) {","\tvar set = \" \" + elem.className + \" \";","","\t// Class name may appear multiple times","\twhile ( set.indexOf( \" \" + name + \" \" ) >= 0 ) {","\t\tset = set.replace( \" \" + name + \" \", \" \" );","\t}","","\t// trim for prettiness","\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace( /^\\s+|\\s+$/g, \"\" );","}","","function id( name ) {","\treturn defined.document && document.getElementById && document.getElementById( name );","}","","function getUrlConfigHtml() {","\tvar i, j, val,","\t\tescaped, escapedTooltip,","\t\tselection = false,","\t\tlen = config.urlConfig.length,","\t\turlConfigHtml = \"\";","","\tfor ( i = 0; i < len; i++ ) {","\t\tval = config.urlConfig[ i ];","\t\tif ( typeof val === \"string\" ) {","\t\t\tval = {","\t\t\t\tid: val,","\t\t\t\tlabel: val","\t\t\t};","\t\t}","","\t\tescaped = escapeText( val.id );","\t\tescapedTooltip = escapeText( val.tooltip );","","\t\tconfig[ val.id ] = QUnit.urlParams[ val.id ];","\t\tif ( !val.value || typeof val.value === \"string\" ) {","\t\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + escaped +","\t\t\t\t\"' name='\" + escaped + \"' type='checkbox'\" +","\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +","\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +","\t\t\t\t\" title='\" + escapedTooltip + \"' /><label for='qunit-urlconfig-\" + escaped +","\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label + \"</label>\";","\t\t} else {","\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped +","\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label +","\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escaped +","\t\t\t\t\"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";","","\t\t\tif ( QUnit.is( \"array\", val.value ) ) {","\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {","\t\t\t\t\tescaped = escapeText( val.value[ j ] );","\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped + \"'\" +","\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?","\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +","\t\t\t\t\t\t\">\" + escaped + \"</option>\";","\t\t\t\t}","\t\t\t} else {","\t\t\t\tfor ( j in val.value ) {","\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {","\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +","\t\t\t\t\t\t\t( config[ val.id ] === j ?","\t\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +","\t\t\t\t\t\t\t\">\" + escapeText( val.value[ j ] ) + \"</option>\";","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t\tif ( config[ val.id ] && !selection ) {","\t\t\t\tescaped = escapeText( config[ val.id ] );","\t\t\t\turlConfigHtml += \"<option value='\" + escaped +","\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" + escaped + \"</option>\";","\t\t\t}","\t\t\turlConfigHtml += \"</select>\";","\t\t}","\t}","","\treturn urlConfigHtml;","}","","// Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.","// Updates the URL with the new state of `config.urlConfig` values.","function toolbarChanged() {","\tvar updatedUrl, value,","\t\tfield = this,","\t\tparams = {};","","\t// Detect if field is a select menu or a checkbox","\tif ( \"selectedIndex\" in field ) {","\t\tvalue = field.options[ field.selectedIndex ].value || undefined;","\t} else {","\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;","\t}","","\tparams[ field.name ] = value;","\tupdatedUrl = QUnit.url( params );","","\tif ( \"hidepassed\" === field.name && \"replaceState\" in window.history ) {","\t\tconfig[ field.name ] = value || false;","\t\tif ( value ) {","\t\t\taddClass( id( \"qunit-tests\" ), \"hidepass\" );","\t\t} else {","\t\t\tremoveClass( id( \"qunit-tests\" ), \"hidepass\" );","\t\t}","","\t\t// It is not necessary to refresh the whole page","\t\twindow.history.replaceState( null, \"\", updatedUrl );","\t} else {","\t\twindow.location = updatedUrl;","\t}","}","","function toolbarUrlConfigContainer() {","\tvar urlConfigContainer = document.createElement( \"span\" );","","\turlConfigContainer.innerHTML = getUrlConfigHtml();","","\t// For oldIE support:","\t// * Add handlers to the individual elements instead of the container","\t// * Use \"click\" instead of \"change\" for checkboxes","\taddEvents( urlConfigContainer.getElementsByTagName( \"input\" ), \"click\", toolbarChanged );","\taddEvents( urlConfigContainer.getElementsByTagName( \"select\" ), \"change\", toolbarChanged );","","\treturn urlConfigContainer;","}","","function toolbarModuleFilterHtml() {","\tvar i,","\t\tmoduleFilterHtml = \"\";","","\tif ( !modulesList.length ) {","\t\treturn false;","\t}","","\tmodulesList.sort(function( a, b ) {","\t\treturn a.localeCompare( b );","\t});","","\tmoduleFilterHtml += \"<label for='qunit-modulefilter'>Module: </label>\" +","\t\t\"<select id='qunit-modulefilter' name='modulefilter'><option value='' \" +","\t\t( QUnit.urlParams.module === undefined ? \"selected='selected'\" : \"\" ) +","\t\t\">< All Modules ></option>\";","","\tfor ( i = 0; i < modulesList.length; i++ ) {","\t\tmoduleFilterHtml += \"<option value='\" +","\t\t\tescapeText( encodeURIComponent( modulesList[ i ] ) ) + \"' \" +","\t\t\t( QUnit.urlParams.module === modulesList[ i ] ? \"selected='selected'\" : \"\" ) +","\t\t\t\">\" + escapeText( modulesList[ i ] ) + \"</option>\";","\t}","\tmoduleFilterHtml += \"</select>\";","","\treturn moduleFilterHtml;","}","","function toolbarModuleFilter() {","\tvar toolbar = id( \"qunit-testrunner-toolbar\" ),","\t\tmoduleFilter = document.createElement( \"span\" ),","\t\tmoduleFilterHtml = toolbarModuleFilterHtml();","","\tif ( !moduleFilterHtml ) {","\t\treturn false;","\t}","","\tmoduleFilter.setAttribute( \"id\", \"qunit-modulefilter-container\" );","\tmoduleFilter.innerHTML = moduleFilterHtml;","","\taddEvent( moduleFilter.lastChild, \"change\", function() {","\t\tvar selectBox = moduleFilter.getElementsByTagName( \"select\" )[ 0 ],","\t\t\tselection = decodeURIComponent( selectBox.options[ selectBox.selectedIndex ].value );","","\t\twindow.location = QUnit.url({","\t\t\tmodule: ( selection === \"\" ) ? undefined : selection,","","\t\t\t// Remove any existing filters","\t\t\tfilter: undefined,","\t\t\ttestId: undefined","\t\t});","\t});","","\ttoolbar.appendChild( moduleFilter );","}","","function appendToolbar() {","\tvar toolbar = id( \"qunit-testrunner-toolbar\" );","","\tif ( toolbar ) {","\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );","\t}","}","","function appendBanner() {","\tvar banner = id( \"qunit-banner\" );","","\tif ( banner ) {","\t\tbanner.className = \"\";","\t\tbanner.innerHTML = \"<a href='\" +","\t\t\tQUnit.url({ filter: undefined, module: undefined, testId: undefined }) +","\t\t\t\"'>\" + banner.innerHTML + \"</a> \";","\t}","}","","function appendTestResults() {","\tvar tests = id( \"qunit-tests\" ),","\t\tresult = id( \"qunit-testresult\" );","","\tif ( result ) {","\t\tresult.parentNode.removeChild( result );","\t}","","\tif ( tests ) {","\t\ttests.innerHTML = \"\";","\t\tresult = document.createElement( \"p\" );","\t\tresult.id = \"qunit-testresult\";","\t\tresult.className = \"result\";","\t\ttests.parentNode.insertBefore( result, tests );","\t\tresult.innerHTML = \"Running...<br />&#160;\";","\t}","}","","function storeFixture() {","\tvar fixture = id( \"qunit-fixture\" );","\tif ( fixture ) {","\t\tconfig.fixture = fixture.innerHTML;","\t}","}","","function appendUserAgent() {","\tvar userAgent = id( \"qunit-userAgent\" );","\tif ( userAgent ) {","\t\tuserAgent.innerHTML = navigator.userAgent;","\t}","}","","function appendTestsList( modules ) {","\tvar i, l, x, z, test, moduleObj;","","\tfor ( i = 0, l = modules.length; i < l; i++ ) {","\t\tmoduleObj = modules[ i ];","","\t\tif ( moduleObj.name ) {","\t\t\tmodulesList.push( moduleObj.name );","\t\t}","","\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {","\t\t\ttest = moduleObj.tests[ x ];","","\t\t\tappendTest( test.name, test.testId, moduleObj.name );","\t\t}","\t}","}","","function appendTest( name, testId, moduleName ) {","\tvar title, rerunTrigger, testBlock, assertList,","\t\ttests = id( \"qunit-tests\" );","","\tif ( !tests ) {","\t\treturn;","\t}","","\ttitle = document.createElement( \"strong\" );","\ttitle.innerHTML = getNameHtml( name, moduleName );","","\trerunTrigger = document.createElement( \"a\" );","\trerunTrigger.innerHTML = \"Rerun\";","\trerunTrigger.href = QUnit.url({ testId: testId });","","\ttestBlock = document.createElement( \"li\" );","\ttestBlock.appendChild( title );","\ttestBlock.appendChild( rerunTrigger );","\ttestBlock.id = \"qunit-test-output-\" + testId;","","\tassertList = document.createElement( \"ol\" );","\tassertList.className = \"qunit-assert-list\";","","\ttestBlock.appendChild( assertList );","","\ttests.appendChild( testBlock );","}","","// HTML Reporter initialization and load","QUnit.begin(function( details ) {","\tvar qunit = id( \"qunit\" );","","\t// Fixture is the only one necessary to run without the #qunit element","\tstoreFixture();","","\tif ( !qunit ) {","\t\treturn;","\t}","","\tqunit.innerHTML =","\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +","\t\t\"<h2 id='qunit-banner'></h2>\" +","\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +","\t\t\"<h2 id='qunit-userAgent'></h2>\" +","\t\t\"<ol id='qunit-tests'></ol>\";","","\tappendBanner();","\tappendTestResults();","\tappendUserAgent();","\tappendToolbar();","\tappendTestsList( details.modules );","\ttoolbarModuleFilter();","","\tif ( config.hidepassed ) {","\t\taddClass( qunit.lastChild, \"hidepass\" );","\t}","});","","QUnit.done(function( details ) {","\tvar i, key,","\t\tbanner = id( \"qunit-banner\" ),","\t\ttests = id( \"qunit-tests\" ),","\t\thtml = [","\t\t\t\"Tests completed in \",","\t\t\tdetails.runtime,","\t\t\t\" milliseconds.<br />\",","\t\t\t\"<span class='passed'>\",","\t\t\tdetails.passed,","\t\t\t\"</span> assertions of <span class='total'>\",","\t\t\tdetails.total,","\t\t\t\"</span> passed, <span class='failed'>\",","\t\t\tdetails.failed,","\t\t\t\"</span> failed.\"","\t\t].join( \"\" );","","\tif ( banner ) {","\t\tbanner.className = details.failed ? \"qunit-fail\" : \"qunit-pass\";","\t}","","\tif ( tests ) {","\t\tid( \"qunit-testresult\" ).innerHTML = html;","\t}","","\tif ( config.altertitle && defined.document && document.title ) {","","\t\t// show âœ– for good, âœ” for bad suite result in title","\t\t// use escape sequences in case file gets loaded with non-utf-8-charset","\t\tdocument.title = [","\t\t\t( details.failed ? \"\\u2716\" : \"\\u2714\" ),","\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )","\t\t].join( \" \" );","\t}","","\t// clear own sessionStorage items if all tests passed","\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {","\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {","\t\t\tkey = sessionStorage.key( i++ );","\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {","\t\t\t\tsessionStorage.removeItem( key );","\t\t\t}","\t\t}","\t}","","\t// scroll back to top to show results","\tif ( config.scrolltop && window.scrollTo ) {","\t\twindow.scrollTo( 0, 0 );","\t}","});","","function getNameHtml( name, module ) {","\tvar nameHtml = \"\";","","\tif ( module ) {","\t\tnameHtml = \"<span class='module-name'>\" + escapeText( module ) + \"</span>: \";","\t}","","\tnameHtml += \"<span class='test-name'>\" + escapeText( name ) + \"</span>\";","","\treturn nameHtml;","}","","QUnit.testStart(function( details ) {","\tvar running, testBlock;","","\ttestBlock = id( \"qunit-test-output-\" + details.testId );","\tif ( testBlock ) {","\t\ttestBlock.className = \"running\";","\t} else {","","\t\t// Report later registered tests","\t\tappendTest( details.name, details.testId, details.module );","\t}","","\trunning = id( \"qunit-testresult\" );","\tif ( running ) {","\t\trunning.innerHTML = \"Running: <br />\" + getNameHtml( details.name, details.module );","\t}","","});","","QUnit.log(function( details ) {","\tvar assertList, assertLi,","\t\tmessage, expected, actual,","\t\ttestItem = id( \"qunit-test-output-\" + details.testId );","","\tif ( !testItem ) {","\t\treturn;","\t}","","\tmessage = escapeText( details.message ) || ( details.result ? \"okay\" : \"failed\" );","\tmessage = \"<span class='test-message'>\" + message + \"</span>\";","\tmessage += \"<span class='runtime'>@ \" + details.runtime + \" ms</span>\";","","\t// pushFailure doesn't provide details.expected","\t// when it calls, it's implicit to also not show expected and diff stuff","\t// Also, we need to check details.expected existence, as it can exist and be undefined","\tif ( !details.result && hasOwn.call( details, \"expected\" ) ) {","\t\texpected = escapeText( QUnit.dump.parse( details.expected ) );","\t\tactual = escapeText( QUnit.dump.parse( details.actual ) );","\t\tmessage += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" +","\t\t\texpected +","\t\t\t\"</pre></td></tr>\";","","\t\tif ( actual !== expected ) {","\t\t\tmessage += \"<tr class='test-actual'><th>Result: </th><td><pre>\" +","\t\t\t\tactual + \"</pre></td></tr>\" +","\t\t\t\t\"<tr class='test-diff'><th>Diff: </th><td><pre>\" +","\t\t\t\tQUnit.diff( expected, actual ) + \"</pre></td></tr>\";","\t\t}","","\t\tif ( details.source ) {","\t\t\tmessage += \"<tr class='test-source'><th>Source: </th><td><pre>\" +","\t\t\t\tescapeText( details.source ) + \"</pre></td></tr>\";","\t\t}","","\t\tmessage += \"</table>\";","","\t// this occours when pushFailure is set and we have an extracted stack trace","\t} else if ( !details.result && details.source ) {","\t\tmessage += \"<table>\" +","\t\t\t\"<tr class='test-source'><th>Source: </th><td><pre>\" +","\t\t\tescapeText( details.source ) + \"</pre></td></tr>\" +","\t\t\t\"</table>\";","\t}","","\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];","","\tassertLi = document.createElement( \"li\" );","\tassertLi.className = details.result ? \"pass\" : \"fail\";","\tassertLi.innerHTML = message;","\tassertList.appendChild( assertLi );","});","","QUnit.testDone(function( details ) {","\tvar testTitle, time, testItem, assertList,","\t\tgood, bad, testCounts, skipped,","\t\ttests = id( \"qunit-tests\" );","","\tif ( !tests ) {","\t\treturn;","\t}","","\ttestItem = id( \"qunit-test-output-\" + details.testId );","","\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];","","\tgood = details.passed;","\tbad = details.failed;","","\t// store result when possible","\tif ( config.reorder && defined.sessionStorage ) {","\t\tif ( bad ) {","\t\t\tsessionStorage.setItem( \"qunit-test-\" + details.module + \"-\" + details.name, bad );","\t\t} else {","\t\t\tsessionStorage.removeItem( \"qunit-test-\" + details.module + \"-\" + details.name );","\t\t}","\t}","","\tif ( bad === 0 ) {","\t\taddClass( assertList, \"qunit-collapsed\" );","\t}","","\t// testItem.firstChild is the test name","\ttestTitle = testItem.firstChild;","","\ttestCounts = bad ?","\t\t\"<b class='failed'>\" + bad + \"</b>, \" + \"<b class='passed'>\" + good + \"</b>, \" :","\t\t\"\";","","\ttestTitle.innerHTML += \" <b class='counts'>(\" + testCounts +","\t\tdetails.assertions.length + \")</b>\";","","\tif ( details.skipped ) {","\t\taddClass( testItem, \"skipped\" );","\t\tskipped = document.createElement( \"em\" );","\t\tskipped.className = \"qunit-skipped-label\";","\t\tskipped.innerHTML = \"skipped\";","\t\ttestItem.insertBefore( skipped, testTitle );","\t} else {","\t\taddEvent( testTitle, \"click\", function() {","\t\t\ttoggleClass( assertList, \"qunit-collapsed\" );","\t\t});","","\t\ttestItem.className = bad ? \"fail\" : \"pass\";","","\t\ttime = document.createElement( \"span\" );","\t\ttime.className = \"runtime\";","\t\ttime.innerHTML = details.runtime + \" ms\";","\t\ttestItem.insertBefore( time, assertList );","\t}","});","","if ( !defined.document || document.readyState === \"complete\" ) {","\tconfig.pageLoaded = true;","\tconfig.autorun = true;","}","","if ( defined.document ) {","\taddEvent( window, \"load\", QUnit.load );","}","","})();"]}]}]]},"ace":{"folds":[],"scrolltop":42915.36241436005,"scrollleft":0,"selection":{"start":{"row":2818,"column":5},"end":{"row":2818,"column":5},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":2775,"state":"start","mode":"ace/mode/javascript"}},"timestamp":1418911260211,"hash":"3f20d1a8b6117e51d8a4ad4dfaab19a66bdc9f0d"}